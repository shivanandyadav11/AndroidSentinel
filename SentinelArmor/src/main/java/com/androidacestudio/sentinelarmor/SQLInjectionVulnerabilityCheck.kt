package com.androidacestudio.sentinelarmor

import android.content.Context
import android.database.sqlite.SQLiteDatabase
import android.database.sqlite.SQLiteOpenHelper
import dalvik.system.DexFile
import java.io.File

/**
 * A security check that identifies potential SQL injection vulnerabilities in Android applications.
 *
 * This check examines various aspects of database usage:
 * - Use of raw SQL queries
 * - Proper use of parameterized queries
 * - Potential string concatenation in SQL queries
 * - Use of content providers for database access
 * - Custom database helper implementations
 *
 * The check analyzes the app's codebase to identify patterns that might indicate
 * SQL injection vulnerabilities.
 *
 * @property context The Android application context, used to access app information and resources.
 *
 * @see SecurityCheck
 * @see SQLiteDatabase
 * @see SQLiteOpenHelper
 */
internal class SQLInjectionVulnerabilityCheck(
    private val context: Context,
) : SecurityCheck {
    /**
     * Performs the SQL injection vulnerability check.
     *
     * This method evaluates various aspects of database usage in the application,
     * returning a list of [SecurityIssue]s if any vulnerabilities are found. The check includes:
     *
     * 1. Analyzing the use of raw SQL queries
     * 2. Checking for proper parameterization of queries
     * 3. Detecting potential string concatenation in SQL queries
     * 4. Examining custom SQLiteOpenHelper implementations
     * 5. Checking for secure use of content providers
     *
     * @return A list of [SecurityIssue]s. If the list is empty, no security issues were detected.
     */
    override fun check(): List<SecurityIssue> {
        val issues = mutableListOf<SecurityIssue>()

        issues.addAll(checkRawSQLUsage())
        issues.addAll(checkParameterizedQueries())
        issues.addAll(checkStringConcatenation())
        issues.addAll(checkCustomSQLiteOpenHelper())
        issues.addAll(checkContentProviderUsage())
        return issues
    }

    /**
     * Checks for the use of raw SQL queries, which might be vulnerable to SQL injection.
     *
     * @return A list of [SecurityIssue]s related to raw SQL usage.
     */
    private fun checkRawSQLUsage(): List<SecurityIssue> {
        val issues = mutableListOf<SecurityIssue>()
        val packageName = context.packageName
        val apkFile = File(context.packageCodePath)

        try {
            DexFile(apkFile).entries().toList().forEach { className ->
                if (className.startsWith(packageName)) {
                    val clazz = Class.forName(className)
                    clazz.declaredMethods.forEach { method ->
                        val body = method.toGenericString()
                        if (body.contains("rawQuery") || body.contains("execSQL")) {
                            issues.add(
                                SecurityIssue(
                                    severity = Severity.HIGH,
                                    description = "Potential use of raw SQL query detected in ${clazz.simpleName}.${method.name}",
                                    recommendation = "Use parameterized queries or prepared statements instead of raw SQL to prevent SQL injection.",
                                ),
                            )
                        }
                    }
                }
            }
        } catch (e: Exception) {
            issues.add(
                SecurityIssue(
                    severity = Severity.LOW,
                    description = "Unable to analyze raw SQL usage: ${e.message}",
                    recommendation = "Manually review the codebase for raw SQL queries and ensure they are properly secured.",
                ),
            )
        }
        return issues
    }

    /**
     * Checks for proper use of parameterized queries to prevent SQL injection.
     *
     * @return A list of [SecurityIssue]s related to query parameterization.
     */
    private fun checkParameterizedQueries(): List<SecurityIssue> {
        val issues = mutableListOf<SecurityIssue>()
        val packageName = context.packageName
        val apkFile = File(context.packageCodePath)

        try {
            DexFile(apkFile).entries().toList().forEach { className ->
                if (className.startsWith(packageName)) {
                    val clazz = Class.forName(className)
                    clazz.declaredMethods.forEach { method ->
                        val body = method.toGenericString()
                        if (body.contains("query(") && !body.contains("selectionArgs")) {
                            issues.add(
                                SecurityIssue(
                                    severity = Severity.MEDIUM,
                                    description = "Potential use of non-parameterized query detected in ${clazz.simpleName}.${method.name}",
                                    recommendation = "Use parameterized queries with selectionArgs to prevent SQL injection.",
                                ),
                            )
                        }
                    }
                }
            }
        } catch (e: Exception) {
            issues.add(
                SecurityIssue(
                    severity = Severity.LOW,
                    description = "Unable to analyze query parameterization: ${e.message}",
                    recommendation = "Manually review the codebase for proper use of parameterized queries.",
                ),
            )
        }
        return issues
    }

    /**
     * Checks for potential string concatenation in SQL queries, which might lead to SQL injection.
     *
     * @return A list of [SecurityIssue]s related to string concatenation in queries.
     */
    private fun checkStringConcatenation(): List<SecurityIssue> {
        val issues = mutableListOf<SecurityIssue>()
        val packageName = context.packageName
        val apkFile = File(context.packageCodePath)

        try {
            DexFile(apkFile).entries().toList().forEach { className ->
                if (className.startsWith(packageName)) {
                    val clazz = Class.forName(className)
                    clazz.declaredMethods.forEach { method ->
                        val body = method.toGenericString()
                        if ((
                                body.contains("query(") ||
                                    body.contains("rawQuery(") ||
                                    body.contains(
                                        "execSQL(",
                                    )
                            ) &&
                            (body.contains(" + ") || body.contains(".append("))
                        ) {
                            issues.add(
                                SecurityIssue(
                                    severity = Severity.HIGH,
                                    description = "Potential string concatenation in SQL query detected in ${clazz.simpleName}.${method.name}",
                                    recommendation = "Avoid string concatenation in SQL queries. Use parameterized queries instead.",
                                ),
                            )
                        }
                    }
                }
            }
        } catch (e: Exception) {
            issues.add(
                SecurityIssue(
                    severity = Severity.LOW,
                    description = "Unable to analyze string concatenation in queries: ${e.message}",
                    recommendation = "Manually review the codebase for string concatenation in SQL queries.",
                ),
            )
        }
        return issues
    }

    /**
     * Checks for custom SQLiteOpenHelper implementations and their security.
     *
     * @return A list of [SecurityIssue]s related to custom SQLiteOpenHelper usage.
     */
    private fun checkCustomSQLiteOpenHelper(): List<SecurityIssue> {
        val issues = mutableListOf<SecurityIssue>()
        val packageName = context.packageName
        val apkFile = File(context.packageCodePath)

        try {
            DexFile(apkFile).entries().toList().forEach { className ->
                if (className.startsWith(packageName)) {
                    val clazz = Class.forName(className)
                    if (SQLiteOpenHelper::class.java.isAssignableFrom(clazz)) {
                        issues.add(
                            SecurityIssue(
                                severity = Severity.LOW,
                                description = "Custom SQLiteOpenHelper detected: ${clazz.simpleName}",
                                recommendation = "Review the custom SQLiteOpenHelper implementation for proper security measures.",
                            ),
                        )
                    }
                }
            }
        } catch (e: Exception) {
            issues.add(
                SecurityIssue(
                    severity = Severity.LOW,
                    description = "Unable to analyze custom SQLiteOpenHelper implementations: ${e.message}",
                    recommendation = "Manually review custom SQLiteOpenHelper classes for security vulnerabilities.",
                ),
            )
        }
        return issues
    }

    /**
     * Checks for secure use of content providers for database access.
     *
     * @return A list of [SecurityIssue]s related to content provider usage.
     */
    private fun checkContentProviderUsage(): List<SecurityIssue> {
        val issues = mutableListOf<SecurityIssue>()
        val packageName = context.packageName
        val apkFile = File(context.packageCodePath)

        try {
            DexFile(apkFile).entries().toList().forEach { className ->
                if (className.startsWith(packageName)) {
                    val clazz = Class.forName(className)
                    if (android.content.ContentProvider::class.java.isAssignableFrom(clazz)) {
                        val methods = clazz.declaredMethods
                        if (methods.any { it.name == "query" || it.name == "insert" || it.name == "update" || it.name == "delete" }) {
                            issues.add(
                                SecurityIssue(
                                    severity = Severity.MEDIUM,
                                    description = "Content Provider with database operations detected: ${clazz.simpleName}",
                                    recommendation = "Ensure proper input validation and query parameterization in Content Provider methods",
                                ),
                            )
                        }
                    }
                }
            }
        } catch (e: Exception) {
            issues.add(
                SecurityIssue(
                    severity = Severity.LOW,
                    description = "Unable to analyze Content Provider usage: ${e.message}",
                    recommendation = "Manually review Content Providers for secure database access.",
                ),
            )
        }
        return issues
    }
}
